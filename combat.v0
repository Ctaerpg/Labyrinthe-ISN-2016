from graphics_isn import *

#test du combat avec un monstre normal qui ne fait qu'attaquer !

#bug si la fenetre est pas 600x600 !!!!!!! limiter la fenetre à ça ou essayer de le regler pendant la remise a neuf du code pas beau :c

#possibilité d'ouvrir deux instances de fenetre graphique python ?
x=600
y=600

def bdd_m(): #mini "bdd" des monstres puis 4 fonctions retournant les caractéristiques du monstre choisi aléatoirement ---> concaténer ? puis du joueur ----> systeme de sauvegarde par la suite
    #du type monstre=[attaque,(defense,)hp,mana]
    global monstre_combat    
    monstre1=[1,0,10,10]
    monstre2=[2,0,20,10]
    monstre3=[5,0,30,0]
    monstres=[monstre1,monstre2,monstre3]
    monstres_choix=alea_int(0,len(monstres)-1)
    monstre_combat=monstres[monstres_choix]
    return monstre_combat

def bdd_hp_m(): #trop de global ??????? ---> a ne pas en abuser, mais comment faire sinon pour faire des petites fonctions ?
    global hp_m
    hp_m=monstre_combat[2]
    return hp_m

def bdd_mana_m():
    global mana_m
    mana_m=monstre_combat[3]
    return mana_m
    
def bdd_att_m():
    global att_m
    att_m=monstre_combat[0]
    return att_m
    
def bdd_def_m():
    global def_m
    def_m=monstre_combat[1]
    return def_m    

def bdd_hp_j():
    global hp_j
    hp_j=50
    return hp_j

def bdd_mana_j():
    global mana_j
    mana_j=10
    return mana_j    
    
#Affique les zones de clics, le monstre, et le personnage
def aff_init():
    init_graphic(x,y,"Mini-RPG")
    draw_line(Point(0,11*y/12),Point(x,11*y/12),white) #zone de contrôle avec clics -> attaque
    draw_line(Point(x/4,11*y/12),Point(x/4,y),white) # -> magie
    draw_line(Point(3*x/4,11*y/12),Point(3*x/4,y),white) # -> defense
    draw_line(Point(2*x/4,11*y/12),Point(2*x/4,y),white) # -> fuite/sac
    texte="Attaque" #affichage de la case attaque
    aff_pol(texte,15,Point(0,11*y/12),white)
    texte="Magie" #affichage de la case magie
    aff_pol(texte,15,Point(x/4,11*y/12),white)
    texte="Defense" #affichage de la case defense
    aff_pol(texte,15,Point(2*x/4,11*y/12),white)
    texte="???" #soon?
    aff_pol(texte,15,Point(3*x/4,11*y/12),white)
    draw_rectangle(Point(135,500),80,50,white) #carré joueur
    texte="Joueur" #affichage du joueur
    aff_pol(texte,15,Point(100,500),white)
    draw_rectangle(Point(535,100),80,50,white) #carré monstre
    texte="Monstre"  #affichage du monstre
    aff_pol(texte,15,Point(500,100),white)
    texte="HP:" #affichage hp/mana joueur
    aff_pol(texte,15,Point(350,435),red)
    aff_pol(texte,15,Point(90,100),red)
    texte="MANA:"
    aff_pol(texte,15,Point(350,490),blue)
    aff_pol(texte,15,Point(90,150),blue)
    bdd_hp_j() #affiche les barres de vie/mana etc --> a changer ! (qd 50 pdv, 50 carrés)
    aff_hp_j(hp_j)
    bdd_hp_m()    
    aff_hp_m(hp_m)
    bdd_mana_j()
    aff_mana_j(mana_j)
    bdd_mana_m()    
    aff_mana_m(mana_m)

def aff_hp_j(hp_j): #cf au dessus + bug, gerer l'affichage ---> voir avec anthony pour le graphisme
    k=100
    for i in range(hp_j):
        k+=25
        draw_fill_rectangle(Point(100+k,475),25,25,red) #compteur de la vie du joueur
        
def aff_mana_j(mana_j):
    k=100
    for i in range(mana_j):
        k+=25
        draw_fill_rectangle(Point(100+k,525),25,25,blue)

def aff_hp_m(hp_m):
    k=100
    for i in range(hp_m):
        k+=25
        draw_fill_rectangle(Point(100+k,100),25,25,red) #compteur de la vie du monstre
        
def aff_mana_m(mana_m):
    k=100
    for i in range(mana_m):
        k+=25
        draw_fill_rectangle(Point(100+k,150),25,25,blue)

def deroulement_combat():
    global hp_m #globalisation des variables --> a changer !
    global hp_j
    global mana_m
    global mana_j
    global att_m
    defense=0 #defense de base du joueur, trouver où le mettre/comment changer
    P=wait_clic()
    if P.y<=(11*x/12):
        return 0
    if P.x<=(x/4) and P.y>=(11*x/12): #si le joueur clique dans la case attaque, le monstre perd 1 hp
        hp_m-=1
        print("attaque + hp_m",hp_m)
        aff_hp_m(hp_m)
    elif P.x<=(2*x/4) and P.x>=(x/4) and P.y>=(11*x/12) and mana_j>0: #si le joueur clique dans la case magie, le monstre perd 2 hp, et le joueur 1 mana, regarde si le joueur a assez de mana
        hp_m-=2
        mana_j-=1
        print("magie + hp_m",hp_m)
        aff_hp_m(hp_m)
    elif P.x<=(3*x/4) and P.x>=(2*x/4) and P.y>=(11*x/12): #si le joueur clique dans defense, divise les dégats qu'il prend par 2
        print("def ---> ne fait rien")
        defense=1
    else:
        return 0
    attendre(250) #attend pour plus de fluidité
    print("hp_j before "+str(hp_j))
    if defense==1: #si def = 1
        hp_j-=ceil(int(bdd_att_m())/2) #dégat arrondi au supérieur divisé par 2
        print("hp_j after "+str(hp_j)+" att_m "+str(bdd_att_m()))
        draw_fill_rectangle(Point(x/4,y/2),1000,200,black) #cache ce qu'il y a au milieu de l'écran pour éviter la superposition
        attendre(750) #attend  pour plus de fluidité
        texte="Le monstre vous a attaqué et vous avez perdu "+str(ceil(int(bdd_att_m())/2))+" pdv deux fois moins car vous vous êtes défendu, vous êtes à "+str(hp_j)+" pdv." #petit texte pour le joueur
        aff_pol(texte,10,Point(x/4-100,y/2),red)
        texte="Le monstre a "+str(hp_m)+" pdv restants." #idem
        aff_pol(texte,10,Point(x/4,y/2+50),red)
        attendre(250) #idem
        aff_hp_j(hp_j)
        print("hp_j end "+str(hp_j))
        defense=0 #réinitialise la defense 
    else: #idem sauf que les dégats sont entiers
        hp_j-=bdd_att_m()
        print("hp_j after "+str(hp_j)+" att_m "+str(bdd_att_m()))
        draw_fill_rectangle(Point(x/4,y/2),1000,200,black)
        attendre(750)
        texte="Le monstre vous a attaqué et vous avez perdu "+str(bdd_att_m())+" pdv, vous êtes à "+str(hp_j)+" pdv."
        aff_pol(texte,10,Point(x/4-100,y/2),red)
        texte="Le monstre a "+str(hp_m)+" pdv restants." #gérer si les pdv sont négatifs
        aff_pol(texte,10,Point(x/4,y/2+50),red)
        attendre(250)
        aff_hp_j(hp_j)
        print("hp_j end "+str(hp_j))
        

def main():
    global hp_j #globalisation.....
    global hp_m
    global mana_j
    bdd_m() #définir les caracs du monstre init ----> changer et mettre dans un tableur/.txt pour la sauvegarde
    bdd_hp_j() #définir les hp du joueur init
    bdd_mana_j()
    combat=1 #initialise le combat --> période de test, elever et rajouter un event de rencontre avec un mob comment initialisateur
    aff_init() #affiche la zone des touches de combats etc. le graphisme test
    if hp_m==10: #petit affichage test
        aff_pol("monstre1",15,Point(x/4+50,y/15),red)
    elif hp_m==20:
        aff_pol("monstre2",15,Point(x/4+50,y/15),red)
    elif hp_m==30:
        aff_pol("monstre3",15,Point(x/4+50,y/15),red)        
    if combat==1: #si combat lancé et tant que les hps sont positifs (et donc qu'ils vivent tous les deux) faire le combat
        while hp_j>0 and hp_m>0:
            deroulement_combat()
        wait_escape()

print(main())
